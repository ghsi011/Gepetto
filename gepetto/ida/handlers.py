import functools
import json
import re
import time
import textwrap

import idaapi
import ida_hexrays
import idc
import idautils
import ida_kernwin

import gepetto.config
from gepetto.models.model_manager import instantiate_model

_ = gepetto.config._


def comment_callback(address, view, response, start_time):
    """
    Callback that sets a comment at the given address.
    :param address: The address of the function to comment
    :param view: A handle to the decompiler window
    :param response: The comment to add
    """
    elapsed_time = time.time() - start_time
    response = "\n".join(textwrap.wrap(response, 80, replace_whitespace=False))

    # Add the response as a comment in IDA, but preserve any existing non-Gepetto comment
    comment = idc.get_func_cmt(address, 0)
    comment = re.sub(
        r'----- ' + _("Comment generated by Gepetto") + ' -----.*?----------------------------------------',
        r"",
        comment,
        flags=re.DOTALL)

    idc.set_func_cmt(address, '----- ' + _("Comment generated by Gepetto") +
                     f" -----\n\n"
                     f"{response.strip()}\n\n"
                     f"----------------------------------------\n\n"
                     f"{comment.strip()}", 0)
    # Refresh the window so the comment is displayed properly
    if view:
        view.refresh_view(False)
    print(_("{model} query finished in {time:.2f} seconds!").format(model=str(gepetto.config.model), time=elapsed_time))

# -----------------------------------------------------------------------------

def conversation_callback(response, memory):
    """
    Callback that simply prints the model's response in IDA's output window.
    :param response: The response returned by the model
    :param memory: The list of messages exchanged so far, so that it can be updated.
    :return:
    """
    memory.append({"role": "assistant", "content": response})

    print()
    for line in response.split("\n"):
        if not line.strip():
            continue
        print(f"{str(gepetto.config.model)}> {line}")
    print()

# -----------------------------------------------------------------------------

class ExplainHandler(idaapi.action_handler_t):
    """
    This handler is tasked with querying the model for an explanation of the
    given function. Once the reply is received, it is added as a function
    comment.
    """

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        start_time = time.time()
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        gepetto.config.model.query_model_async(
            _("Can you explain what the following C function does and suggest a better name for "
              "it?\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, start_time=start_time))
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------

def rename_callback(address, view, response):
    """
    Callback that extracts a JSON array of old names and new names from the
    response and sets them in the pseudocode.
    :param address: The address of the function to work on
    :param view: A handle to the decompiler window
    :param response: The response from the model
    """
    names = json.loads(response)

    # get the function name from the response - it should be the first key in the JSON array
    function_name = next(iter(names.values()))
    # rename the function
    try_rename_with_suffixes(address, function_name, idc.SN_CHECK | idc.SN_NOWARN)

    #remove the function name from the JSON array
    names.pop(next(iter(names.keys())))

    # The rename function needs the start address of the function
    function_addr = idaapi.get_func(address).start_ea

    replaced = []
    for n in names:
        if idaapi.IDA_SDK_VERSION < 760:
            lvars = {lvar.name: lvar for lvar in view.cfunc.lvars}
            if n in lvars:
                if view.rename_lvar(lvars[n], names[n], True):
                    replaced.append(n)
        else:
            if ida_hexrays.rename_lvar(function_addr, n, names[n]):
                replaced.append(n)

    # Update possible names left in the function comment
    comment = idc.get_func_cmt(address, 0)
    if comment and len(replaced) > 0:
        for n in replaced:
            comment = re.sub(r'\b%s\b' % n, names[n], comment)
        idc.set_func_cmt(address, comment, 0)

    # Refresh the window to show the new names
    if view:
        view.refresh_view(True)
    print(_("{model} query finished! {replaced} variable(s) renamed.").format(model=str(gepetto.config.model),
                                                                              replaced=len(replaced)))


# -----------------------------------------------------------------------------

# Attempt to apply name; if duplicate, generate deterministic suffixes _1, _2, ...
def try_rename_with_suffixes(address, base_name, flags):
    suffix = 0
    applied = False
    while suffix < 100:  # arbitrary safety cap
        candidate = base_name if suffix == 0 else f"{base_name}_{suffix}"
        if idc.set_name(address, candidate, flags):
            print(_("Function 0x{ea:X} renamed to {name}").format(ea=address, name=candidate))
            applied = True
            break
        suffix += 1
    if not applied:
        print(_("Failed to rename function 0x{ea:X} to {name} (even after suffix attempts)").format(ea=address, name=base_name))
    return applied


class RenameHandler(idaapi.action_handler_t):
    """
    This handler requests new variable names from the model and updates the
    decompiler's output.
    """

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        gepetto.config.model.query_model(
            _("Analyze the following C function:\n{decompiler_output}"
              "\nSuggest better variable names and a function name, reply with a JSON array where keys are the original"
              " names and values are the proposed names. the function name should always be first in the array. Do not explain anything, only print the "
              "JSON dictionary.").format(decompiler_output=str(decompiler_output)),
            functools.partial(rename_callback, address=idaapi.get_screen_ea(), view=v),
            additional_model_options={"response_format": {"type": "json_object"}})
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------

class SwapModelHandler(idaapi.action_handler_t):
    """
    This handler replaces the model currently in use with another one selected by the user,
    and updates the configuration.
    """

    def __init__(self, new_model, plugin):
        self.new_model = new_model
        self.plugin = plugin

    def activate(self, ctx):
        try:
            gepetto.config.model = instantiate_model(self.new_model)
        except ValueError as e:  # Raised if an API key is missing. In which case, don't switch.
            print(_("Couldn't change model to {model}: {error}").format(model=self.new_model, error=str(e)))
            return
        gepetto.config.update_config("Gepetto", "MODEL", self.new_model)
        # Refresh the menus to reflect which model is currently selected.
        self.plugin.generate_model_select_menu()

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class GenerateCCodeHandler(idaapi.action_handler_t):
    """
    This handler requests the model to generate executable C code from the given
    decompiled C function. The generated code is saved to a file.
    """
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        gepetto.config.model.query_model_async(
            _("Please generate executable C code based on the following decompiled C code and ensure it includes all necessary header files and other information:\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(self._save_c_code, view=v)
        )
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def _save_c_code(self, view, response):
        """
        Callback that saves the generated C code to a file.
        :param view: A handle to the decompiler window
        :param response: The generated C code from the model
        """
        project_name = idaapi.get_root_filename()
        func_name = idc.get_func_name(idaapi.get_screen_ea())
        file_name = f"{project_name}_{func_name}.c"
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(response)

        if view:
            view.refresh_view(False)
        print(_("{model} generated code saved to {file_name}").format(model=str(gepetto.config.model), file_name=file_name))

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class GeneratePythonCodeHandler(idaapi.action_handler_t):
    """
    This handler requests the model to generate executable C code from the given
    decompiled C function. The generated code is saved to a file.
    """
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        gepetto.config.model.query_model_async(
            _("Please generate equivalent Python code based on the following decompiled C code, and provide an example of the function call:\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(self._save_python_code, view=v)
        )
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def _save_python_code(self, view, response):
        """
        Callback that saves the generated python code to a file.
        :param view: A handle to the decompiler window
        :param response: The generated python code from the model
        """
        project_name = idaapi.get_root_filename()
        func_name = idc.get_func_name(idaapi.get_screen_ea())
        file_name = f"{project_name}_{func_name}.py"
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(response)

        if view:
            view.refresh_view(False)
        print(_("{model} generated code saved to {file_name}").format(model=str(gepetto.config.model), file_name=file_name))

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS





def rename_function_callback(address, response, view):
    """Callback to set a better function name returned by the model.

    The model is expected to reply with a single identifier (no JSON). Additional text is
    ignored; only the first token is used as the new name.
    """
    new_name = response.strip().split()[0] if response else ""
    new_name = re.sub(r"[^0-9A-Za-z_]", "_", new_name)  # sanitize
    if not new_name:
        print(_("Model did not return a valid function name."))
        return
    

    base_name = new_name
    flags = idc.SN_CHECK | idc.SN_NOWARN
    try_rename_with_suffixes(address, base_name, flags)
    
    if view:
        view.refresh_view(True)
        print("refreshed view")
    else:
        print("no view")


class FunctionRenameHandler(idaapi.action_handler_t):
    """Requests a better function name from the model and applies it."""

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        if not decompiler_output:
            return 0
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        gepetto.config.model.query_model(
            _("Suggest a concise, descriptive C-style identifier as a better name for the following function."
              " Return ONLY the new name, without any explanation.\n{code}").format(code=str(decompiler_output)),
            functools.partial(rename_function_callback, address=idaapi.get_screen_ea(), view=v)
        )
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------
# Combined rename orchestration


class CombinedRenameHandler(idaapi.action_handler_t):
    """Runs variable rename first, then function rename, leveraging existing callbacks."""
    def __init__(self):
        self.varRenameHandler = RenameHandler()
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        return self.varRenameHandler.activate(ctx)

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------
# Recursive combined rename (leaf-first)
# -----------------------------------------------------------------------------


def _collect_descendant_functions_leaf_first(start_ea: int, visited: set[int] | None = None, ordered: list[int] | None = None):
    """Return list of function start EAs in depth-first post-order (leaf first)."""
    if visited is None:
        visited = set()
    if ordered is None:
        ordered = []
    if start_ea in visited:
        return ordered
    visited.add(start_ea)
    func = idaapi.get_func(start_ea)
    if not func:
        return ordered
    # iterate over instructions to find call targets
    for ea in idautils.FuncItems(func.start_ea):
        for xref in idautils.XrefsFrom(ea, idaapi.XREF_FAR):
            if xref.type not in (idaapi.fl_CN, idaapi.fl_CF):
                continue
            callee = idaapi.get_func(xref.to)
            if callee:
                _collect_descendant_functions_leaf_first(callee.start_ea, visited, ordered)
    ordered.append(func.start_ea)
    return ordered


class RecursiveCombinedRenameHandler(idaapi.action_handler_t):
    """Action that applies CombinedRenameHandler recursively leaf-first."""

    def __init__(self):
        self.RenameHandler = RenameHandler()
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        start_ea = idaapi.get_screen_ea()
        ordered = _collect_descendant_functions_leaf_first(start_ea)
        if not ordered:
            print(_("No functions found to process."))
            return 0
        
        for ea in ordered:
            ida_kernwin.jumpto(ea)
            self.RenameHandler.activate(ctx)

        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
